diff --git a/vpx/src/vpx_image.c b/vpx/src/vpx_image.c
index 36eda95..ed05faa 100644
--- a/vpx/src/vpx_image.c
+++ b/vpx/src/vpx_image.c
@@ -12,6 +12,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include "vpx/vpx_image.h"
+#include "vpx/vpx_integer.h"
 
 #define ADDRESS_STORAGE_SIZE      sizeof(size_t)
 /*returns an addr aligned to the byte boundary specified by align*/
@@ -124,11 +125,10 @@ static vpx_image_t *img_alloc_helper(vpx_image_t  *img,
       break;
   }
 
-  /* Calculate storage sizes given the chroma subsampling */
-  align = (1 << xcs) - 1;
-  w = (d_w + align) & ~align;
-  align = (1 << ycs) - 1;
-  h = (d_h + align) & ~align;
+  /* Calculate storage sizes. If the buffer was allocated externally, the width
+   * and height shouldn't be adjusted. */
+  w = d_w;
+  h = d_h;
   s = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;
   s = (s + stride_align - 1) & ~(stride_align - 1);
 
@@ -147,8 +147,22 @@ static vpx_image_t *img_alloc_helper(vpx_image_t  *img,
   img->img_data = img_data;
 
   if (!img_data) {
-    img->img_data = img_buf_memalign(buf_align, ((fmt & VPX_IMG_FMT_PLANAR) ?
-                                                 h * s * bps / 8 : h * s));
+    uint64_t alloc_size;
+    /* Calculate storage sizes given the chroma subsampling */
+    align = (1 << xcs) - 1;
+    w = (d_w + align) & ~align;
+    align = (1 << ycs) - 1;
+    h = (d_h + align) & ~align;
+
+    s = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;
+    s = (s + stride_align - 1) & ~(stride_align - 1);
+    /* no VPX_IMG_FMT_HIGHBITDEPTH in this version, so stride_in_bytes = s */
+    //stride_in_bytes = (fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? s * 2 : s;
+    alloc_size = (fmt & VPX_IMG_FMT_PLANAR) ? (uint64_t)h * s * bps / 8
+                                            : (uint64_t)h * s;
+    if(alloc_size != (size_t)alloc_size) goto fail;
+
+    img->img_data = img_buf_memalign(buf_align, (size_t)alloc_size);
     img->img_data_owner = 1;
   }


